Redis的数据结构有：字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。  

高级一点的还有：HyperLogLog、Geo、Pub/Sub  

Redis 分布式锁可用setnx来争抢，expire配上过期时间可以自动释放。  

不过为了防止意外发生导至锁无法释放，可以用set整合成一条指令来解决  
set key value NX EX ttl  

Redis里有1亿个Key，想查出10W个前缀一样的Key，用Keys xx*,不过吃效率，线上环境不能这么玩，会阻塞，得结合scan指令，  
scan取出的数据无阻塞，不过会有一点重复，自己想办法去重。  

Redis的异步队列用list结构实现，rpush生产消息，lpop消费消息，没有消息时，用sleep休息一会。  
不用sleep的话，用blpop指令，在没有消息的时候，会阻塞直到有消息。  

如果有一个生产对多个消费的场景，就用发布/订阅（pub/sub）的方式，它的缺点是消费者下线后生产的消息就会消失。  

Redis如何实现延时队列，本身是没有，要用Sorted Set有序集合，时间戳作为score，消息内容为Key，用Zadd加入集合。  
zrangebyscore指令来取N秒之前的数据轮询进行处理。  

大量的Key需要设置同时过期，这个不好，会造成那个时间点卡，不要同时过期，每个过期的时间加个随机值分散数据。  

Redis的持久化，一种是RDB方式，其中的BGSAVE指令会让Redis fork出子进程来把数据保存到磁盘，当然，这个开销很大。  
还有一种是AOF方式，在Redis操作数据时会同时记录到AOF文件中，作为同步。  

一般在重启后恢复数据基本上是先用BGSAVE的文件重构内存，再用AOF记录的文件进行精准恢复。  

不过AOF有个sync的配置，是指定恢复的时间的，一种是实时的，开销很大，不现实。一种是定时的，也就是每隔个几秒写一次，如果要求不高的话，用后者。  

Pipeline就什么？其实就是一种管道，简单理解就是批量写入，可以节省IO开销。  

Redis的同步机制是主从、从从同时。没太多花头。  

另外还有Redis的集群。  

最后，不要觉得这些都掌握了就OK了，大部分的面试都会问你Redis实现的原理是什么。  
