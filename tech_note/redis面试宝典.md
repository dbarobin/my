Redis的数据结构有：  

字符串 String、字典 Hash、列表 List、集合 Set、有序集合 SortedSet。  

高级一点的还有：  

HyperLogLog、Geo、Pub/Sub  

Redis分布式锁可用**setnx**来争抢，**expire**配上过期时间可以自动释放。  

不过为了防止意外发生导至锁无法释放，可以用**set**整合成一条指令来解决  

set key value NX EX ttl  

Redis里有1亿个Key，想查出10W个前缀一样的Key，用`Keys xx*`，这个的缺点是吃效率，线上环境不能这么玩，会阻塞，得结合**scan**指令。  

scan取出的数据无阻塞，但数据会有一点重复，自己想办法去重。  

Redis的异步队列用**list**结构实现，rpush生产消息，lpop消费消息，没有消息时，用sleep休息一会。  
不用sleep的话，用blpop指令，在没有消息的时候，会阻塞直到有消息。  

如果有一个生产对多个消费的场景，就用**发布/订阅（pub/sub）**的方式，它的缺点是消费者下线后生产的消息就会消失。  

Redis如何实现延时队列，本身是没有，要用Sorted Set有序集合，时间戳作为score，消息内容为Key，用Zadd加入集合。  

zrangebyscore指令来取N秒之前的数据轮询进行处理。  

大量的Key需要设置同时过期的情况下，会造成那个时间点卡，所以不要同时过期，每个过期的时间加个**随机值**分散数据的过期时间。  

Redis的持久化，一种是**RDB方式**，其中的**BGSAVE**指令会让Redis fork出子进程来把数据保存到磁盘，当然，这个开销很大。  
还有一种是**AOF方式**，在Redis操作数据时会同时记录到AOF文件中，作为同步。  

一般在重启后恢复数据基本上是先用BGSAVE的文件重构内存，再用AOF记录的文件进行精准恢复。  

AOF有个**sync**的配置，是指定恢复的时间的。可设置成实时的或是非实时的。前者开销很大，不现实。后者则是定时的，也就是每隔个N秒写一次记录，如果要求不高的话，用后者。  

**Pipeline**是什么？其实就是一种管道，简单理解就是批量写入，可以节省IO开销。  

Redis的同步机制是主从、从从同时。具体看手册。  

另外还有Redis的集群。  

最后，不要觉得这些都掌握了面试就OK了，大部分的面试都会来问你Redis实现的具体原理是什么的。  
