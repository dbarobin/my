### 基础篇  

#### 基本功  

##### 面向对象的特征  
抽象、继承、封装、多态性  
多态性是指允许不同类的对象对同一消息作出响应。  

##### final, finally, finalize 的区别  
在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。  
当用final修饰一个类时，表明这个类不能被继承。  

使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。  

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。  

#### int 和 Integer 有什么区别  
Ingeter是int的包装类，int的初值为0，Ingeter的初值为null。  
int与integer的区别从大的方面来说就是基本数据类型与其包装类的区别：  
int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象  
int 是基本数据类型（面向过程留下的痕迹，不过是对java的有益补充），Integer 是一个类，是int的扩展，定义了很多的转换方法  
比如当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装 object的，这是就需要这些基本类型的包装类了。  

#### 重载和重写的区别  
在Java程序中，类的继承关系可以产生一个子类，子类继承父类，它具备了父类所有的特征，继承了父类所有的方法和变量。  
子类可以定义新的特征，当子类需要修改父类的一些方法进行扩展，增大功能，程序设计者常常把这样的一种操作方法称为重写，也叫称为覆写或覆盖。  

方法重载是让类以统一的方式处理不同类型数据的一种手段。调用方法时通过传递给它们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。  
所谓方法重载是指在一个类中，多个方法的方法名相同，但是参数列表不同。参数列表不同指的是参数个数、参数类型或者参数的顺序不同。  

#### 抽象类和接口有什么区别  
1、在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2、一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

#### 说说反射的用途及实现  
允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。  

通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息。  

当我们在使用 IDE（如 Eclipse\IDEA）时，当我们输入一个队长或者类并向调用它的属性和方法时，一按 (“.”)点号，编译器就会自动列出她的属性或方法，这里就会用到反射  

很多框架（比如 Spring）都是配置化的（比如通过 XML文件配置 JavaBean，Action之类的），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。  

#### 说说自定义注解的场景及实现  
Annotation(注解)是JDK5.0及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。  

解是以‘@注解名’在代码中存在的，根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。它们都不会直接影响到程序的语义，只是作为注解（标识）存在，我们可以通过反射机制编程实现对这些元数据（用来描述数据的数据）的访问。  
在日常編程中，我們遇到的註解有@Override、@SuppressWarnings等等，@Override表示重寫父類的方法，@SuppressWarnings表示忽略警告信息。  

#### HTTP 请求的 GET 与 POST 方式的区别  
操……略  

#### session 与 cookie 区别  
操……略  

#### session 分布式处理  
1.基于数据库的Session共享  
2.基于NFS共享文件系统  
3.基于memcached 的session  
4.基于resin/tomcat web容器本身的session复制机制  
5.基于TT/Redis 或 jbosscache 进行 session 共享。  
6.基于cookie 进行session共享  

#### JDBC 流程  
注册驱动、连接数据库、创建搬运工statement、搬运数据,执行SQL语句、处理结果集、关闭连接  

### MVC 设计思想  
M他妈的VC，现在都前后端分离了，后端只提供API  

### equals 与 == 的区别  
== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是指相同一个对象。比较的是真正意义上的指针操作。  
equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。  
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
Object.class给出equals()方法的定义，竟然只是简单地通过==去实现判断。而==在java中用于判断存储在栈中的值是否相等。我们的基本数据类型像int的比较都用==，因为基本数据类型就存放在栈中，同样存放在栈中的，还有引用数据类型的引用，而真正的对象本身则存放在堆中。因此，这里给出的equals()方法就只是比较两个对象在内存中的引用（即地址）是否相等。本例中新建了两个对象，在内存中就新开辟了两个内存空间，引用地址当然是不一样的，程序运行结果当然是不相同。  
