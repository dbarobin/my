### JVM的类加载机制是什么？有哪些实现方式？

**类加载机制：**

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法去内，然后在堆区创建一个java.lang.Class对象，用来封装在方法区内的数据结构。类的加载最终是在堆区内的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。  

加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

1、通过一个类的全限定名来获取其定义的二进制字节流。  
2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。  
3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。  

### 类加载有三种方式：

1、命令行启动应用时候由JVM初始化加载
```java
Dog dog ＝ new Dog（）； 
这个动作会导致常量池的解析，Dog类被隐式装载。 
如果当前ClassLoader无法找到Dog，则抛出NoClassDefFoundError。 
```

2、通过Class.forName()方法动态加载
```java
Class clazz ＝ Class.forName（"Dog"）； 
Object dog ＝clazz.newInstance（）； 
通过反射加载类型，并创建对象实例 
如果无法找到Dog，则抛出ClassNotFoundException。 
```

3、通过ClassLoader.loadClass()方法动态加载  
```java
Class clazz ＝ classLoader.loadClass（"Dog"）； 
Object dog ＝clazz.newInstance（）； 
通过反射加载类型，并创建对象实例 
如果无法找到Dog，则抛出ClassNotFoundException。
```

### JVM的常见垃圾回收算法？

1、标记-清除算法  
最基础的。  
前后线标记处所有需要回收的对象，在标记完成后统一回收有被标记的对象。  
缺点：一个是效率问题，不高。一个是空间的问题，标记清除后会产生大量不连续的内存碎片。 

2、复制算法  
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将其活着的对象存在另外一块上面，然后再把已使用过的内存空间一次清理掉。
代介是内存空间被占用了一半。  

3、标记-整理算法  
标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

4、分代收集算法  
当代商业虚拟机都用这个。  
一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代都发现有大批对象死去，选用复制算法。老年代中因为对象存活率高，必须使用“标记-清理”或“标记-整理”算法来进行回收。

`注：这个问题的知识，在《深入理解 Java虚拟机：JVM高级特性与最佳实践》上都有详细说明，推荐阅读这本。`

### JVM调优的常见命令行工具有哪些？JVM常见的调优参数有哪些？

#### JVM调优的常见命令工具包括：

* jps  
JVM process Status Tool  
虚拟进程状况工具。用于查询正在运行的JVM进程，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称及进程在本地虚拟机唯一ID。

* jstat  
JVM Statistics Monitoring Tool  
虚拟机统计信息监视工具  
可以实时显示本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据  

* jinfo  
Configuration Info for Java  
Java配置信息工具  
用于查询当前运行这的JVM属性和参数的值。  
实时地查看和调整虚拟机各项参数。  

* jmap  
Memory Map for Java  
用于显示当前Java堆和永久代的详细信息  
用于生成堆转储快照，一般称为heapdump或是dump文件。  

* jhat  
JVM Heap Analysis Tool  
用于分析使用jmap生成的dump文件，是JDK自带的工具  
一般不会用这个，比较简陋，有其它的更专业的工具。  

* jstack  
Stack Trace for java  
Java堆栈跟踪工具  
用于生成当前JVM的所有线程快照（一般称为threaddump或javacore文件），线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合,目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待。

另外还要记住两个强大的可视化工具：JConsole和VisualVM。  

* JConsole  
Java Monitoring and Management Console  
Java监视与管理控制台（具体看了下有点复杂，记得就行）  

* VisualVM  
All-in-One Java Troubleshooting Tool。  
最强大的，运行监视和故障处理程序。  

#### JVM常见的调优参数包括：

* -Xmx  
指定java程序的最大堆内存, 使用java -Xmx5000M -version判断当前系统能分配的最大堆内存

* -Xms  
指定最小堆内存, 通常设置成跟最大堆内存一样，减少GC`垃圾收集`

* -Xmn
设置年轻代大小。整个堆大小 = 年轻代大小 + 年老代大小。所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

* -Xss  
指定线程的最大栈空间, 此参数决定了java函数调用的深度, 值越大调用深度越深, 若值太小则容易出栈溢出错误(StackOverflowError)

* -XX:PermSize  
指定方法区(永久区)的初始值,默认是物理内存的1/64， 在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

* -XX:MaxPermSize  
指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小

* -XX:NewRatio=n  
年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1

* -XX:SurvivorRatio=n  
Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)

`eden就相当于是使用空间，survivor就相当于是保留空间`  

`年轻代：所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。`

`年老代： 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。`

`永久代：用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。`

`注：这个问题的知识，同样在《深入理解 Java虚拟机：JVM高级特性与最佳实践》上都有详细说明，这本还是必备一下吧，有电子版。`

### ConcurrentHashMap加锁机制是什么，详细说一下？

HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。  

https://github.com/gundamzaku/my/blob/master/java_technology/%E5%BF%AB%E6%89%8BJava%E9%9D%A2%E8%AF%95%E9%A2%98.md  
可以看这里的关于ConcurrentHashMa的内容，更详细一点。不过基本用ConcurrentHashMap解决什么问题要记住。  

### G1收集器简介？以及它的内存划分怎么样的？

简介：

Garbage-First（G1，垃圾优先）收集器是服务类型的收集器，目标是多处理器机器、大内存机器。它高度符合垃圾收集暂停时间的目标，同时实现高吞吐量。Oracle JDK 7 update 4 以及更新发布版完全支持G1垃圾收集器  

特点：  

并行与并发，G1能利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间。  
分代收集，效果更好。  
空间整合，整体基于“标记-整理”的算法，局部基于“复制”算法。可以很好的避免空间碎片，有利于程序长时间运行，特别是分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
可以预测的停顿，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
G1的内存划分方式：

它是将堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成老一代收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。

`注：还是那本书……好好看看`  

### 在重写equals方法时，需要遵循哪些约定，具体介绍一下？

重写equals方法时需要遵循通用约定：自反性、对称性、传递性、一致性.、非空性

1）自反性

对于任何非null的引用值x,x.equals(x)必须返回true。---这一点基本上不会有啥问题

2）对称性

对于任何非null的引用值x和y，当且仅当x.equals(y)为true时，y.equals(x)也为true。

3）传递性

对于任何非null的引用值x、y、z。如果x.equals(y)==true,y.equals(z)==true,那么x.equals(z)==true。

4） 一致性

对于任何非null的引用值x和y，只要equals的比较操作在对象所用的信息没有被修改，那么多次调用x.eqals(y)就会一致性地返回true,或者一致性的返回false。

5）非空性

所有比较的对象都不能为空。

### Synchronized优化后的锁机制简单介绍一下，包括自旋锁、偏向锁、轻量级锁、重量级锁？

自旋锁：

线程自旋说白了就是让cup在做无用功，比如：可以执行几次for循环，可以执行几条空的汇编指令，目的是占着CPU不放，等待获取锁的机会。如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。

偏向锁

偏向锁就是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免CAS操作，

说白了就是置个变量，如果发现为true则无需再走各种加锁/解锁流程。

轻量级锁：

轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；

重量级锁

重量锁在JVM中又叫对象监视器（Monitor），它很像C中的Mutex，除了具备Mutex(0|1)互斥的功能，它还负责实现了Semaphore(信号量)的功能，也就是说它至少包含一个竞争锁的队列，和一个信号阻塞队列（wait队列），前者负责做互斥，后一个用于做线程同步。

偏向锁、轻量级锁、重量级锁的对比



Redis和Memcache区别对比？如何选择这两个技术？


区别：

1） Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。

2）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。

3）虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘

4）过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10

5）分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从

6）存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）

7）灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复

8）Redis支持数据的备份，即master-slave模式的数据备份。

选型：

若是简单的存取key-value这样的数据用memcache好一些

若是要支持数据持久化，多数据类型(如集合、散列之类的)，用列表类型做队列之类的高级应用，就用redis

Redis的持久化机制是什么？各自的优缺点？

redis提供两种持久化机制RDB和AOF机制。

1）RDB持久化方式：

是指用数据集快照的方式记录redis数据库的所有键值对。

优点：

　　1.只有一个文件dump.rdb，方便持久化。

　　2.容灾性好，一个文件可以保存到安全的磁盘。

　　3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。

　　4.相对于数据集大时，比AOF的启动效率更高。

缺点：

　　1.数据安全性低。

2）AOF持久化方式：

是指所有的命令行记录以redis命令请求协议的格式保存为aof文件。

优点：

　　1.数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。

　　2.通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。

　　3.AOF机制的rewrite模式。

缺点：

　　1.文件会比RDB形式的文件大。

　　2.数据集大的时候，比rdb启动效率低。

Mysql的数据库表锁、行锁、页级锁？

表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许

行级,，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。

页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

数据库的四大特征，数据库的隔离级别？

数据库的四大特征：

（1）原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。

（2）一致性（Consistency）

一个事务执行之前和执行之后都必须处于一致性状态。

（3）隔离性（Isolation）

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

4）持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。

 数据库的隔离级别：

1）Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。3）Read committed (读已提交)：可避免脏读的发生。4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。

set集合从原理上如何保证不重复

1）在往set中添加元素时，如果指定元素不存在，则添加成功。也就是说，如果set中不存在(e==null ? e1==null : e.queals(e1))的元素e1,则e1能添加到set中。

2）具体来讲：当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后用这个（元素的hashcode）%（HashMap集合的大小）+1计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。

HashMap和HashTable的主要区别是什么？，两者底层实现的数据结构是什么？

HashMap和HashTable的区别：

二者都实现了Map 接口，是将惟一键映射到特定的值上；主要区别在于：

1)HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；

2)HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和

containsKey,因为contains 方法容易让人引起误解；

3)Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；

4)Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。

HashMap和HashTable的底层实现数据结构：

HashMap和Hashtable的底层实现都是数组+链表结构实现的

HashMap何时扩容，扩容的算法是什么？

HashMap何时扩容：

当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容

扩容的算法是什么：

扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组

Java的虚拟机JVM的两个内存：栈内存和堆内存的区别是什么？

Java把内存划分成两种：一种是栈内存，一种是堆内存。两者的区别是：

1）栈内存：在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

2）堆内存：堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。

Java中对异常是如何进行分类的？

异常整体分类：

1）Java异常结构中定义有Throwable类。 Exception和Error为其子类。

2）其中Exception表示由于网络故障、文件损坏、设备错误、用户输入非法情况导致的异常；

3）而Error标识Java运行时环境出现的错误，例如：JVM内存耗尽。

数据库设计中常讲的三范式是指什么？

1）第一范式1NF(域的原子性)

如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式

2）第二范式2NF(表中除主键外的字段都完全依赖主键)

第二范式是在第一范式基础上建立的。第二范式有两个重点:(1)表中必须有主键；(2)其他非主属性必须完全依赖主键，不能只依赖主键的一部分（主要针对联合主键而言）。

3）第三范式3NF（表中除主键外的字段都完全直接依赖，不能是传递依赖）

不能是传递依赖，即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。第二范式和第三范式区分的关键点：2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。

Java中的线程池共有几种？

Java四种线程池

第一种：newCachedThreadPool

　　创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。

第二种：newFixedThreadPool

　　创建一个指定工作线程数量的线程池

第三种：newScheduledThreadPool

创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

第四种：newSingleThreadExecutor

　　创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。

volatile和synchronized区别

volatile和synchronized简介：

在Java中,为了保证多线程读写数据时保证数据的一致性,可以采用两种方式：

　 1）使用synchronized关键字

　 2）使用volatile关键字：用一句话概括volatile,它能够使变量在值发生改变时能尽快地让其他线程知道。

两者的区别：

1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住.

2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.

3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.

4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.

Spring的特性

1.方便解耦，简化开发

通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。

2.AOP编程的支持

通过Spring提供的AOP功能，方便进行面向切面的编程。

3.声明事物的支持

在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。

4.方便程序的测试

可以用非容器依赖的编程方式进行几乎所有的测试工作。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。

5.方便集成各种优秀框架

Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts,Hibernate、Hessian、Quartz）等的直接支持。

6.降低Java EE API的使用难度

Spring对很多难用的Java EE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些Java EE API的使用难度大为降低。

spring aop的应用场景：

AOP用来封装横切关注点，具体可以在下面的场景中使用

Authentication 权限

Caching 缓存

Context passing 内容传递

Error handling 错误处理

Lazy loading 懒加载

Debugging 调试

logging, tracing, profiling and monitoring 记录跟踪 优化 校准

Performance optimization 性能优化

Persistence 持久化

Resource pooling 资源池

Synchronization 同步

Transactions 事务

Mybaits中#和$区别

1）${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。

2）#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。

排序都有哪几种方法？请列举。用JAVA 实现一个快速排序。

排序的方法有：

插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）；

快速排序的伪代码：

//使用快速排序方法对a[ 0 :n- 1 ]排序

从a[ 0 :n- 1 ]中选择一个元素作为middle，该元素为支点；

把余下的元素分割为两段left 和right，使得left 中的元素都小于等于支点，

而right 中的元素都大于等于支点；

递归地使用快速排序方法对left 进行排序；

递归地使用快速排序方法对right 进行排序；

所得结果为left + middle + right。

快速排序的Java代码实现如下：
