### 数据存储

#### MySQL 索引使用的注意事项  
略

#### 说说反模式设计  
略

#### 说说分库与分表设计  
略

#### 分库与分表带来的分布式困境与应对之策  
略

#### 说说 SQL 优化之道  
略

#### MySQL 遇到的死锁问题  

一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。  

解决方法：  
这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理，必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。  

#### 存储引擎的 InnoDB 与 MyISAM  
MyISAM已经不太用了  

#### 数据库索引的原理  
有点难度，几句话讲不清楚  

#### 为什么要用 B-tree  
使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。而B+tree是B-tree的一个变种  

#### 聚集索引与非聚集索引的区别  
聚集索引类似拼音查找，表中存储的数据按照索引的顺序存储，检索效率比普通索引高，索引占用硬盘    
非聚集索引类似偏旁查找，不影响表中的数据存储顺序，检索效率比聚集索引低，索引占用硬盘存储  

1.聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。  
2.聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。  
3.聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之。  

InnoDB按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。  
所以，对于 聚集索引 来说，你创建主键的时候，自动就创建了主键的聚集索引。  

#### limit 20000 加载很慢怎么解决  
分批加载？  

#### 选择合适的分布式主键方案  
通过应用程序生成一个GUID，然后和数据一起插入切分后的集群。  
通过独立的应用程序事先在数据库中生成一系列唯一的 ID，各应用程序通过接口或者自己去读取再和数据一起插入到切分后的集群中。  
通过中心数据库服务器利用数据库自身的自增类型（如 MySQL的 auto_increment 字段），或者自增对象（如 Oracle 的 Sequence）等先生成一个唯一 ID 再和数据一起插入切分后的集群。  
通过集群编号加集群内的自增（auto_increment类型）两个字段共同组成唯一主键。  
通过设置每个集群中自增 ID 起始点（auto_increment_offset），将各个集群的ID进行绝对的分段来实现全局唯一。  
通过设置每个集群中自增 ID 起始点（auto_increment_offset）以及 ID 自增步长（auto_increment_increment），让目前每个集群的起始点错开 1，步长选择大于将来基本不可能达到的切分集群数，达到将 ID 相对分段的效果来满足全局唯一的效果。  

#### 选择合适的数据存储方案  
在服务端会经常遇到数据存储的选型问题，是选择使用关系型数据库 MySQL，还是选择内存数据库 Redis，还是选择文档数据库 MongoDB，还是选择列族数据库 HBase， 还是选择全文搜索引擎 ElasticSearch 呢？  

#### ObjectId 规则  
mongo的，跳过  

#### 聊聊 MongoDB 使用场景  
跳过  

#### 倒排索引  
英文原名Inverted index，大概因为 Invert 有颠倒的意思，就被翻译成了倒排。但是倒排这个名称很容易让人理解为从A-Z颠倒成Z-A。个人认为翻译成转置索引可能比较合适。一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。  

#### 聊聊 ElasticSearch 使用场景  
搜索引擎  

