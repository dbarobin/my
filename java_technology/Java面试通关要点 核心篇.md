### 数据存储

#### MySQL 索引使用的注意事项  
略

#### 说说反模式设计  
略

#### 说说分库与分表设计  
略

#### 分库与分表带来的分布式困境与应对之策  
略

#### 说说 SQL 优化之道  
略

#### MySQL 遇到的死锁问题  

一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。  

解决方法：  
这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理，必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。  

#### 存储引擎的 InnoDB 与 MyISAM  
MyISAM已经不太用了  

#### 数据库索引的原理  
有点难度，几句话讲不清楚  

#### 为什么要用 B-tree  
使用B-tree结构可以显著减少定位记录时所经历的中间过程，从而加快存取速度。而B+tree是B-tree的一个变种  

#### 聚集索引与非聚集索引的区别  
聚集索引类似拼音查找，表中存储的数据按照索引的顺序存储，检索效率比普通索引高，索引占用硬盘    
非聚集索引类似偏旁查找，不影响表中的数据存储顺序，检索效率比聚集索引低，索引占用硬盘存储  

1.聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。  
2.聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。  
3.聚集索引查询数据速度快，插入数据速度慢；非聚集索引反之。  

InnoDB按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。  
所以，对于 聚集索引 来说，你创建主键的时候，自动就创建了主键的聚集索引。  

#### limit 20000 加载很慢怎么解决  
分批加载？  

#### 选择合适的分布式主键方案  
通过应用程序生成一个GUID，然后和数据一起插入切分后的集群。  
通过独立的应用程序事先在数据库中生成一系列唯一的 ID，各应用程序通过接口或者自己去读取再和数据一起插入到切分后的集群中。  
通过中心数据库服务器利用数据库自身的自增类型（如 MySQL的 auto_increment 字段），或者自增对象（如 Oracle 的 Sequence）等先生成一个唯一 ID 再和数据一起插入切分后的集群。  
通过集群编号加集群内的自增（auto_increment类型）两个字段共同组成唯一主键。  
通过设置每个集群中自增 ID 起始点（auto_increment_offset），将各个集群的ID进行绝对的分段来实现全局唯一。  
通过设置每个集群中自增 ID 起始点（auto_increment_offset）以及 ID 自增步长（auto_increment_increment），让目前每个集群的起始点错开 1，步长选择大于将来基本不可能达到的切分集群数，达到将 ID 相对分段的效果来满足全局唯一的效果。  

#### 选择合适的数据存储方案  
在服务端会经常遇到数据存储的选型问题，是选择使用关系型数据库 MySQL，还是选择内存数据库 Redis，还是选择文档数据库 MongoDB，还是选择列族数据库 HBase， 还是选择全文搜索引擎 ElasticSearch 呢？  

#### ObjectId 规则  
mongo的，跳过  

#### 聊聊 MongoDB 使用场景  
跳过  

#### 倒排索引  
英文原名Inverted index，大概因为 Invert 有颠倒的意思，就被翻译成了倒排。但是倒排这个名称很容易让人理解为从A-Z颠倒成Z-A。个人认为翻译成转置索引可能比较合适。一个未经处理的数据库中，一般是以文档ID作为索引，以文档内容作为记录。而Inverted index 指的是将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。  

#### 聊聊 ElasticSearch 使用场景  
搜索引擎  

### 缓存使用

#### Redis 有哪些类型  
字符串，散列表，列表，集合，有序集合。  

#### Redis 内部结构  
Redis一个重要的基础数据结构：dict。
在Redis内部，有非常多的数据结构：sds（简单动态字符串），list，intset（整数集合），hash（字典），zskiplist（跳跃表），ziplist（压缩表）等。  

#### 聊聊 Redis 使用场景  
跳过  

#### Redis 持久化机制  
RDB持久化和AOF持久化  

#### Redis 如何实现持久化  
日志恢复  

#### Redis 集群方案与实现  
1.Redis官方集群方案 Redis Cluster  
2.Redis Sharding集群  
3.利用代理中间件实现大规模Redis集群  
twemproxy  

#### Redis 为什么是单线程的  

Redis操作的是内存中的数据结构。如果在多线程中操作，那就需要为这些对象加锁。  
所以使用多线程可以提高性能，但是每个线程的效率严重下降了，而且程序的逻辑严重复杂化。Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，这些操作还可以合成MULTI/EXEC的组。这样一个操作中可能就需要加非常多的锁，导致的结果是同步开销大大增加。Redis在权衡之后的选择是用单线程，突出自己功能的灵活性。在单线程基础上任何原子操作都可以几乎无代价地实现，多么复杂的数据结构都可以轻松运用，甚至可以使用Lua脚本这样的功能。对于多线程来说这需要高得多的代价。  

#### 缓存奔溃  

一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。  

给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。 

缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。  

解决的办法就是：如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。  

对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。还有最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。  

也可以采用一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。  

雪崩  

在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。  
可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存  
不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀  
做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。  

#### 缓存降级  

surging的缓存降级就是针对于proxy进行拦截，如果有缓存数据，则返回缓存数据，否则调用Proceed方法调用远程服务。  
在数据进行update,delete的时候就需要针对于依赖的缓存进行删除，可以通过proxy进行拦截的方式把缓存进行删除  
缓存降级有以下优点  
1.高性能：可以减少响应时间和提高吞吐量  
2.高效：针对于业务逻辑的设计，无需考虑缓存，做到了无缝集成  

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。  


#### 使用缓存的合理性问题  

热点数据，缓存才有价值  

频繁修改的数据，看情况考虑使用缓存  

如一读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。  

数据不一致性  

缓存是提高数据读取性能的，缓存数据丢失和缓存不可用不会影响应用程序的处理。因此，一般的操作手段是，如果Redis出现异常，我们手动捕获这个异常，记录日志，并且去数据库查询数据返回给用户。  
缓存服务降级  
服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。  
缓存预热  
缓存穿透  
